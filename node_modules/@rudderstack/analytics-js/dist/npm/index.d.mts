type LoggerProvider$1 = Record<Exclude<Lowercase<LogLevel>, Lowercase<'NONE'>>, (...data: any[]) => void>;
interface ILogger {
    minLogLevel: number;
    scope?: string;
    logProvider: LoggerProvider$1;
    log(...data: any[]): void;
    info(...data: any[]): void;
    debug(...data: any[]): void;
    warn(...data: any[]): void;
    error(...data: any[]): void;
    setScope(scopeVal: string): void;
    setMinLogLevel(logLevel: LogLevel): void;
}
type LogLevel = 'LOG' | 'INFO' | 'DEBUG' | 'WARN' | 'ERROR' | 'NONE';

type LoggerProvider = Record<Exclude<Lowercase<LogLevel>, Lowercase<'NONE'>>, (...data: any[]) => void>;

/**
 * Service to log messages/data to output provider, default is console
 */
declare class Logger implements ILogger {
    minLogLevel: number;
    scope?: string;
    logProvider: LoggerProvider;
    constructor(minLogLevel?: LogLevel, scope?: string, logProvider?: Console);
    log(...data: any[]): void;
    info(...data: any[]): void;
    debug(...data: any[]): void;
    warn(...data: any[]): void;
    error(...data: any[]): void;
    outputLog(logMethod: LogLevel, data: any[]): void;
    setScope(scopeVal: string): void;
    setMinLogLevel(logLevel: LogLevel): void;
    /**
     * Formats the console message using `scope` and styles
     */
    formatLogData(data: any[]): any[];
}//# sourceMappingURL=Logger.d.ts.map

type Nullable<T> = T | null;

/**
 * Represents a generic object in the APIs
 * Use for parameters like properties, traits etc.
 */
type ApiObject = {
    [index: string]: string | number | boolean | ApiObject | null | Date | (string | number | boolean | null | Date | ApiObject | undefined)[] | undefined;
};

type DestinationIntgConfig = boolean | undefined | ApiObject;
/**
 * Represents the integration options object
 * Example usages:
 * integrationOptions { All: false, "Google Analytics": true, "Braze": true}
 * integrationOptions { All: true, "Chartbeat": false, "Customer.io": false}
 * integrationOptions { All: true, "GA4": { "clientId": "1234" }, "Google Analytics": false }
 */
type IntegrationOpts = {
    All?: boolean;
    [index: string]: DestinationIntgConfig;
};

type ApiCallback = (data?: any) => void;
/**
 * Represents the options parameter in the APIs
 */
type ApiOptions = {
    integrations?: IntegrationOpts;
    anonymousId?: string;
    originalTimestamp?: string;
    [index: string]: string | number | boolean | ApiObject | null | Date | (string | number | boolean | ApiObject)[] | undefined;
};
type APIEvent = {
    type: RudderEventType;
    category?: string;
    name?: string;
    properties?: Nullable<ApiObject>;
    options?: Nullable<ApiOptions>;
    callback?: () => void;
    userId?: Nullable<string>;
    traits?: Nullable<ApiObject>;
    to?: string;
    from?: string;
    groupId?: Nullable<string>;
};
type RudderEventType = 'page' | 'track' | 'identify' | 'alias' | 'group';

interface ExtensionPoint {
    [lifeCycleName: string]: (...args: any[]) => unknown;
}
/**
 * ExtensionPoint can be nested, e.g. 'sdk.initialize.phase1'
 * When index signature is provided, every key have to match the type, the types
 * for 'name', 'deps',  and 'initialize' is added as index signature.
 */
interface ExtensionPlugin {
    name: string;
    initialize?: (state?: any) => void;
    deps?: string[];
    [key: string]: string | (() => void) | ExtensionPoint | ((...args: any[]) => unknown) | string[] | undefined;
}
type PluginEngineConfig = {
    throws?: boolean | RegExp;
};
interface IPluginEngine {
    plugins: ExtensionPlugin[];
    byName: Record<string, ExtensionPlugin>;
    cache: Record<string, ExtensionPlugin[]>;
    config: PluginEngineConfig;
    register: (plugin: ExtensionPlugin, state?: Record<string, any>) => void;
    unregister: (name: string) => void;
    getPlugin: (name: string) => ExtensionPlugin | undefined;
    getPlugins: (extPoint?: string) => ExtensionPlugin[];
    invoke: <T = any>(extPoint?: string, allowMultiple?: boolean, ...args: any[]) => Nullable<T>[];
    invokeSingle: <T = any>(extPoint?: string, ...args: any[]) => Nullable<T>;
    invokeMultiple: <T = any>(extPoint?: string, ...args: any[]) => Nullable<T>[];
}

interface IPluginsManager {
    engine: IPluginEngine;
    init(): void;
    attachEffects(): void;
    setActivePlugins(): void;
    invokeMultiple<T = any>(extPoint?: string, ...args: any[]): Nullable<T>[];
    invokeSingle<T = any>(extPoint?: string, ...args: any[]): Nullable<T>;
    register(plugins: ExtensionPlugin[]): void;
}
type PluginName = 'BeaconQueue' | 'Bugsnag' | 'CustomConsentManager' | 'DeviceModeDestinations' | 'DeviceModeTransformation' | 'ErrorReporting' | 'ExternalAnonymousId' | 'GoogleLinker' | 'IubendaConsentManager' | 'KetchConsentManager' | 'NativeDestinationQueue' | 'OneTrustConsentManager' | 'StorageEncryption' | 'StorageEncryptionLegacy' | 'StorageMigrator' | 'XhrQueue';

type ConsentManagementProvider = 'iubenda' | 'oneTrust' | 'ketch' | 'custom';
type Consents = string[];
type ConsentManagementOptions = {
    enabled?: boolean;
    provider?: ConsentManagementProvider;
    allowedConsentIds?: Consents;
    deniedConsentIds?: Consents;
};

type UserSessionKey = 'userId' | 'userTraits' | 'anonymousId' | 'groupId' | 'groupTraits' | 'initialReferrer' | 'initialReferringDomain' | 'sessionInfo' | 'authToken';

type StorageEncryptionVersion = 'legacy' | 'v3';
type StorageType = 'cookieStorage' | 'localStorage' | 'memoryStorage' | 'sessionStorage' | 'none';
type StorageEncryption = {
    version: StorageEncryptionVersion;
};
type LoadOptionStorageEntry = {
    type: StorageType;
};
type StorageOpts = {
    encryption?: StorageEncryption;
    migrate?: boolean;
    type?: StorageType;
    cookie?: CookieOptions;
    entries?: {
        [key in UserSessionKey]?: LoadOptionStorageEntry;
    };
};
type CookieOptions = {
    maxage?: number;
    expires?: Date;
    path?: string;
    domain?: string;
    samesite?: string;
    secure?: boolean;
};
type CookieSameSite = 'Strict' | 'Lax' | 'None';

type UaChTrackLevel = 'none' | 'default' | 'full';
/**
 * Represents the options parameter for anonymousId
 */
type AnonymousIdOptions = {
    autoCapture?: {
        enabled?: boolean;
        source?: string;
    };
};
type SessionOpts = {
    autoTrack?: boolean;
    timeout?: number;
};
/**
 * Represents the beacon queue options parameter in loadOptions type
 */
type BeaconQueueOpts = {
    maxItems?: number;
    flushQueueInterval?: number;
};
type EventsTransportMode = 'xhr' | 'beacon';
type BatchOpts = {
    enabled: boolean;
    maxItems?: number;
    maxSize?: number;
    flushInterval?: number;
};
/**
 * Represents the queue options parameter in loadOptions type
 */
type QueueOpts = {
    maxRetryDelay?: number;
    minRetryDelay?: number;
    backoffFactor?: number;
    backoffJitter?: number;
    maxAttempts?: number;
    maxItems?: number;
    batch?: BatchOpts;
    timerScaleFactor?: number;
};
/**
 * Represents the destinations queue options parameter in loadOptions type
 */
type DestinationsQueueOpts = {
    maxItems?: number;
};
type OnLoadedCallback = (analytics: any) => void;
type DeliveryType = 'immediate' | 'buffer';
type StorageStrategy = 'none' | 'session' | 'anonymousId';
type PreConsentStorageOptions = {
    strategy: StorageStrategy;
};
type PreConsentEventsOptions = {
    delivery: DeliveryType;
};
type PreConsentOptions = {
    enabled: boolean;
    storage?: PreConsentStorageOptions;
    events?: PreConsentEventsOptions;
};
declare enum PageLifecycleEvents {
    LOADED = "Page Loaded",
    UNLOADED = "Page Unloaded"
}
type PageLifecycleOptions = {
    enabled: boolean;
    events?: PageLifecycleEvents[];
    options?: ApiOptions;
};
type AutoTrackOptions = {
    enabled?: boolean;
    options?: ApiOptions;
    pageLifecycle?: PageLifecycleOptions;
};
/**
 * Represents the options parameter in the load API
 */
type LoadOptions = {
    logLevel?: LogLevel;
    integrations?: IntegrationOpts;
    configUrl?: string;
    queueOptions?: QueueOpts;
    loadIntegration?: boolean;
    sessions?: SessionOpts;
    secureCookie?: boolean;
    destSDKBaseURL?: string;
    pluginsSDKBaseURL?: string;
    useBeacon?: boolean;
    beaconQueueOptions?: BeaconQueueOpts;
    destinationsQueueOptions?: DestinationsQueueOpts;
    anonymousIdOptions?: AnonymousIdOptions;
    setCookieDomain?: string;
    sameSiteCookie?: CookieSameSite;
    lockIntegrationsVersion?: boolean;
    lockPluginsVersion?: boolean;
    polyfillIfRequired?: boolean;
    onLoaded?: OnLoadedCallback;
    uaChTrackLevel?: UaChTrackLevel;
    getSourceConfig?: () => string | ApiObject | Promise<ApiObject> | Promise<string>;
    sendAdblockPage?: boolean;
    sendAdblockPageOptions?: ApiOptions;
    plugins?: Nullable<PluginName[]>;
    polyfillURL?: string;
    useGlobalIntegrationsConfigInEvents?: boolean;
    bufferDataPlaneEventsUntilReady?: boolean;
    dataPlaneEventsBufferTimeout?: number;
    storage?: StorageOpts;
    preConsent?: PreConsentOptions;
    transportMode?: EventsTransportMode;
    consentManagement?: ConsentManagementOptions;
    sameDomainCookiesOnly?: boolean;
    externalAnonymousIdCookieName?: string;
    useServerSideCookies?: boolean;
    dataServiceEndpoint?: string;
    autoTrack?: AutoTrackOptions;
};
type ConsentOptions = {
    storage?: StorageOpts;
    consentManagement?: ConsentManagementOptions;
    integrations?: IntegrationOpts;
    discardPreConsentEvents?: boolean;
    sendPageEvent?: boolean;
    trackConsent?: boolean;
};

type Address = {
    city?: string;
    City?: string;
    country?: string;
    Country?: string;
    postalCode?: string;
    state?: string;
    State?: string;
    street?: string;
};
type Company = {
    name?: string;
    id?: string;
    industry?: string;
    employee_count?: string;
    plan?: string;
};
/**
 * Represents a traits object in the Identify API
 */
type IdentifyTraits = {
    id?: string;
    userId?: string;
    firstName?: string;
    firstname?: string;
    first_name?: string;
    lastName?: string;
    lastname?: string;
    last_name?: string;
    name?: string;
    Name?: string;
    age?: number;
    email?: string;
    Email?: string;
    'E-mail'?: string;
    phone?: string;
    address?: string | Address;
    birthday?: string;
    company?: Company;
    createdAt?: string;
    description?: string;
    gender?: string;
    title?: string;
    username?: string;
    website?: string;
    avatar?: string;
    zip?: string | number;
    state?: string;
    State?: string;
    dob?: string;
    employed?: string | boolean;
    education?: string;
    married?: string | boolean;
    customerType?: string | number;
    euConsent?: string;
    euConsentMessage?: string;
    newEmail?: string;
    tags?: string | string[];
    removeTags?: string | string[];
    prospect?: string | boolean;
    doubleOptin?: string | boolean;
    event_id?: string;
    organization?: string;
    region?: string;
    anonymous?: string | boolean;
    country?: string;
    custom?: string;
    ip?: string;
    privateAttributeNames?: any;
    secondary?: any;
    customPageId?: string;
    isRudderEvents?: boolean;
    optOutType?: boolean | string | number;
    groupType?: string | number;
    anonymousId?: string | number;
    ip_address?: string;
    number?: string | number;
    [index: string]: string | number | boolean | ApiObject | null | Date | (string | number | boolean | null | Date | ApiObject)[] | undefined;
};

type AnalyticsIdentifyMethod = {
    (userId: string, traits?: Nullable<IdentifyTraits>, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    (userId: string, traits?: Nullable<IdentifyTraits>, callback?: ApiCallback): void;
    (userId: string, callback?: ApiCallback): void;
    (traits: Nullable<IdentifyTraits>, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    (traits: Nullable<IdentifyTraits>, callback?: ApiCallback): void;
};
type AnalyticsPageMethod = {
    (category: string, name: string, properties?: Nullable<ApiObject>, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    (category: string, name: string, properties?: Nullable<ApiObject>, callback?: ApiCallback): void;
    (category: string, name: string, callback?: ApiCallback): void;
    (name: string, properties?: Nullable<ApiObject>, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    (name: string, properties?: Nullable<ApiObject>, callback?: ApiCallback): void;
    (name: string, callback?: ApiCallback): void;
    (properties: Nullable<ApiObject>, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    (properties: Nullable<ApiObject>, callback?: ApiCallback): void;
    (callback?: ApiCallback): void;
};
type AnalyticsTrackMethod = {
    (event: string, properties?: Nullable<ApiObject>, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    (event: string, properties?: Nullable<ApiObject>, callback?: ApiCallback): void;
    (event: string, callback?: ApiCallback): void;
};
type AnalyticsGroupMethod = {
    (groupId: string, traits?: Nullable<IdentifyTraits>, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    (groupId: string, traits?: Nullable<IdentifyTraits>, callback?: ApiCallback): void;
    (groupId: string, callback?: ApiCallback): void;
    (traits: Nullable<IdentifyTraits>, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    (traits: Nullable<IdentifyTraits>, callback?: ApiCallback): void;
};
type AnalyticsAliasMethod = {
    (to: string, from?: string, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    (to: string, from?: string, callback?: ApiCallback): void;
    (to: string, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    (to: string, callback?: ApiCallback): void;
};
interface IRudderAnalytics<T = any> {
    analyticsInstances: Record<string, T>;
    defaultAnalyticsKey: string;
    logger: ILogger;
    /**
     * Set the writeKey of the analytics instance that should be default
     */
    setDefaultInstanceKey(writeKey: string, autoSet: boolean): void;
    /**
     * Get the instance of Analytics that is set as default
     */
    getAnalyticsInstance(writeKey?: string): T | undefined;
    /**
     * Trigger load event in buffer queue if exists
     */
    triggerBufferedLoadEvent(): void;
    /**
     * Call control pane to get client configs
     */
    load(writeKey: string, dataPlaneUrl: string, loadOptions?: Partial<LoadOptions>): void;
    /**
     * To register a callback for SDK ready state
     */
    ready(callback: ApiCallback): void;
    /**
     * To record a page view event
     */
    page: AnalyticsPageMethod;
    /**
     * To record a user track event
     */
    track: AnalyticsTrackMethod;
    /**
     * To record a user identification event
     */
    identify: AnalyticsIdentifyMethod;
    /**
     * To record a user alias event
     */
    alias: AnalyticsAliasMethod;
    /**
     * To record a user group event
     */
    group: AnalyticsGroupMethod;
    /**
     * Clear user information
     *
     * @param resetAnonymousId optionally clears anonymousId as well
     */
    reset(resetAnonymousId?: boolean): void;
    /**
     * To get anonymousId set in the SDK
     *
     * @param options options for anonymousId
     */
    getAnonymousId(options?: AnonymousIdOptions): string | undefined;
    /**
     * To set anonymousId
     *
     * @param anonymousId custom anonymousId value
     * @param rudderAmpLinkerParam AMP Linker ID string
     */
    setAnonymousId(anonymousId?: string, rudderAmpLinkerParam?: string): void;
    /**
     * To get userId set in the SDK
     */
    getUserId(): Nullable<string> | undefined;
    /**
     * To get user traits set in the SDK
     */
    getUserTraits(): Nullable<ApiObject> | undefined;
    /**
     * To get groupId set in the SDK
     */
    getGroupId(): Nullable<string> | undefined;
    /**
     * To get group traits set in the SDK
     */
    getGroupTraits(): Nullable<ApiObject> | undefined;
    /**
     * To manually start user session in the SDK
     */
    startSession(sessionId?: number): void;
    /**
     * To manually end user session in the SDK
     */
    endSession(): void;
    /**
     * To set authorization token
     * @param token token value
     */
    setAuthToken(token: string): void;
    /**
     * To fetch the current sessionId
     */
    getSessionId(): Nullable<number> | undefined;
    /**
     * To provide consent
     * @param options Consent API options
     */
    consent(options?: ConsentOptions): void;
}

type PreloadedEventCall = Array<string | any>;
type RudderAnalyticsPreloader = {
    [index: string]: (...args: any[]) => any;
};

/**
 * A buffer queue to serve as a store for any type of data
 */
declare class BufferQueue<T = any> {
    items: T[];
    constructor();
    enqueue(item: T): void;
    dequeue(): Nullable<T> | undefined;
    isEmpty(): boolean;
    size(): number;
    clear(): void;
}
//# sourceMappingURL=BufferQueue.d.ts.map

interface IExternalSourceLoadConfig {
    url: string;
    id: string;
    callback?(id?: string): unknown;
    async?: boolean;
    timeout?: number;
    extraAttributes?: Record<string, string>;
}
interface IExternalSrcLoader {
    errorHandler?: {
        onError(error: unknown, context?: string, customMessage?: string, shouldAlwaysThrow?: boolean): void;
        leaveBreadcrumb(breadcrumb: string): void;
        notifyError(error: Error, errorState: ErrorState): void;
    };
    logger?: ILogger;
    timeout: number;
    loadJSFile(config: IExternalSourceLoadConfig): void;
}

type SDKError = unknown | Error | ErrorEvent | Event | PromiseRejectionEvent;
interface IErrorHandler {
    logger?: ILogger;
    pluginEngine?: IPluginEngine;
    errorBuffer: BufferQueue<PreLoadErrorData>;
    init(httpClient: IHttpClient, externalSrcLoader: IExternalSrcLoader): void;
    onError(error: SDKError, context?: string, customMessage?: string, shouldAlwaysThrow?: boolean, errorType?: string): void;
    leaveBreadcrumb(breadcrumb: string): void;
    notifyError(error: Error, errorState: ErrorState): void;
    attachErrorListeners(): void;
}
type ErrorState = {
    severity: string;
    unhandled: boolean;
    severityReason: {
        type: string;
    };
};
type PreLoadErrorData = {
    error: SDKError;
    errorState: ErrorState;
};

interface IRequestConfig {
    url: string;
    options?: Partial<IXHRRequestOptions>;
    isRawResponse?: boolean;
    timeout?: number;
}
type ResponseDetails = {
    response: string;
    error?: Error;
    xhr?: XMLHttpRequest;
    options: IXHRRequestOptions;
};
type AsyncRequestCallback<T> = (data?: T | string | undefined, details?: ResponseDetails) => void;
interface IAsyncRequestConfig<T> extends IRequestConfig {
    callback?: AsyncRequestCallback<T>;
}
interface IXHRRequestOptions {
    method: HTTPClientMethod;
    url: string;
    headers: Record<string, string | undefined>;
    data?: XMLHttpRequestBodyInit;
    sendRawData?: boolean;
    withCredentials?: boolean;
}
type HTTPClientMethod = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
interface IHttpClient {
    errorHandler?: IErrorHandler;
    logger?: ILogger;
    basicAuthHeader?: string;
    hasErrorHandler: boolean;
    getData<T = any>(config: IRequestConfig): Promise<{
        data: T | string | undefined;
        details?: ResponseDetails;
    }>;
    getAsyncData<T = any>(config: IAsyncRequestConfig<T>): void;
    setAuthHeader(value: string, noBto?: boolean): void;
    resetAuthHeader(): void;
}

type StoreId = string;
interface IStoreConfig {
    name: string;
    id: StoreId;
    isEncrypted?: boolean;
    validKeys?: Record<string, string>;
    noCompoundKey?: boolean;
    errorHandler?: IErrorHandler;
    logger?: ILogger;
    type?: StorageType;
}
interface IStoreManager {
    stores?: Record<StoreId, IStore>;
    isInitialized?: boolean;
    errorHandler?: IErrorHandler;
    logger?: ILogger;
    init(): void;
    initializeStorageState(): void;
    setStore(storeConfig: IStoreConfig): IStore;
    getStore(id: StoreId): IStore | undefined;
}
interface IStore {
    id: string;
    name: string;
    isEncrypted: boolean;
    validKeys: Record<string, string>;
    engine: IStorage;
    originalEngine: IStorage;
    noKeyValidation?: boolean;
    noCompoundKey?: boolean;
    errorHandler?: IErrorHandler;
    logger?: ILogger;
    pluginsManager?: IPluginsManager;
    createValidKey(key: string): string | undefined;
    swapQueueStoreToInMemoryEngine(): void;
    set(key: string, value: any): void;
    get<T = any>(key: string): Nullable<T>;
    remove(key: string): void;
    getOriginalEngine(): IStorage;
    decrypt(value?: Nullable<string>): Nullable<string>;
    encrypt(value: any): string;
    crypto(value: string, mode: 'encrypt' | 'decrypt'): string;
    onError(error: unknown): void;
}
interface IStorage extends Storage {
    configure?(options: StorageOptions): void;
    keys(): string[];
    isEnabled?: boolean;
}
type StorageOptions = Partial<ICookieStorageOptions | ILocalStorageOptions | IInMemoryStorageOptions>;
interface ICookieStorageOptions extends CookieOptions {
    samesite?: CookieSameSite;
    domain?: string;
    secure?: boolean;
    enabled?: boolean;
    sameDomainCookiesOnly?: boolean;
}
interface ILocalStorageOptions {
    enabled?: boolean;
}
interface IInMemoryStorageOptions {
    enabled?: boolean;
}

type PageCallOptions = {
    category?: string;
    name?: string;
    properties?: Nullable<ApiObject>;
    options?: Nullable<ApiOptions>;
    callback?: ApiCallback;
};
type TrackCallOptions = {
    name: string;
    properties?: Nullable<ApiObject>;
    options?: Nullable<ApiOptions>;
    callback?: ApiCallback;
};
type IdentifyCallOptions = {
    userId?: Nullable<string>;
    traits?: Nullable<IdentifyTraits>;
    options?: Nullable<ApiOptions>;
    callback?: ApiCallback;
};
type AliasCallOptions = {
    to: string;
    from?: string;
    options?: Nullable<ApiOptions>;
    callback?: ApiCallback;
};
type GroupCallOptions = {
    groupId?: Nullable<string>;
    traits?: Nullable<ApiObject>;
    options?: Nullable<ApiOptions>;
    callback?: ApiCallback;
};

/**
 * Store Implementation with dedicated storage
 */
declare class Store implements IStore {
    id: string;
    name: string;
    isEncrypted: boolean;
    validKeys: Record<string, string>;
    engine: IStorage;
    originalEngine: IStorage;
    noKeyValidation?: boolean;
    noCompoundKey?: boolean;
    errorHandler?: IErrorHandler;
    hasErrorHandler: boolean;
    logger?: ILogger;
    pluginsManager?: IPluginsManager;
    constructor(config: IStoreConfig, engine?: IStorage, pluginsManager?: IPluginsManager);
    /**
     * Ensure the key is valid and with correct format
     */
    createValidKey(key: string): string | undefined;
    /**
     * Switch to inMemoryEngine, bringing any existing data with.
     */
    swapQueueStoreToInMemoryEngine(): void;
    /**
     * Set value by key.
     */
    set(key: string, value: any): void;
    /**
     * Get by Key.
     */
    get<T = any>(key: string): Nullable<T>;
    /**
     * Remove by Key.
     */
    remove(key: string): void;
    /**
     * Get original engine
     */
    getOriginalEngine(): IStorage;
    /**
     * Decrypt values
     */
    decrypt(value?: Nullable<string>): Nullable<string>;
    /**
     * Encrypt value
     */
    encrypt(value: Nullable<any>): string;
    /**
     * Extension point to use with encryption plugins
     */
    crypto(value: Nullable<any>, mode: 'encrypt' | 'decrypt'): string;
    /**
     * Handle errors
     */
    onError(error: unknown): void;
}
//# sourceMappingURL=Store.d.ts.map

interface IUserSessionManager {
    storeManager?: IStoreManager;
    init(): void;
    setAnonymousId(anonymousId?: string, rudderAmpLinkerParam?: string): void;
    getAnonymousId(options?: AnonymousIdOptions): string;
    refreshSession(): void;
    getSessionId(): Nullable<number>;
    getGroupId(): Nullable<string>;
    getUserId(): Nullable<string>;
    setUserId(userId?: null | string): void;
    setUserTraits(traits?: Nullable<ApiObject>): void;
    getUserTraits(): Nullable<ApiObject>;
    getGroupTraits(): Nullable<ApiObject>;
    setGroupId(groupId?: Nullable<string>): void;
    setGroupTraits(traits?: Nullable<ApiObject>): void;
    reset(resetAnonymousId?: boolean, noNewSessionStart?: boolean): void;
    start(sessionId?: number): void;
    end(): void;
    syncStorageDataToState(): void;
    setAuthToken(token: Nullable<string>): void;
}

interface IConfigManager {
    httpClient: IHttpClient;
    errorHandler?: IErrorHandler;
    logger?: ILogger;
    init: () => void;
    getConfig: () => void;
    processConfig: () => void;
}

interface IEventManager {
    init(): void;
    addEvent(event: APIEvent): void;
    resume(): void;
}

interface ICapabilitiesManager {
    logger?: ILogger;
    errorHandler?: IErrorHandler;
    externalSrcLoader: IExternalSrcLoader;
    init(): void;
    detectBrowserCapabilities(): void;
    prepareBrowserCapabilities(): void;
    attachWindowListeners(): void;
    onReady(): void;
}

interface IAnalytics {
    preloadBuffer: BufferQueue<PreloadedEventCall>;
    initialized: boolean;
    httpClient: IHttpClient;
    logger: ILogger;
    errorHandler: IErrorHandler;
    externalSrcLoader: IExternalSrcLoader;
    capabilitiesManager: ICapabilitiesManager;
    storeManager?: IStoreManager;
    configManager?: IConfigManager;
    eventManager?: IEventManager;
    userSessionManager?: IUserSessionManager;
    pluginsManager?: IPluginsManager;
    clientDataStore?: Store;
    /**
     * Start application lifecycle if not already started
     */
    load(writeKey: string, dataPlaneUrl?: string | Partial<LoadOptions>, loadOptions?: Partial<LoadOptions>): void;
    /**
     * Orchestrate the lifecycle of the application phases/status
     */
    startLifecycle(): void;
    /**
     * Load browser polyfill if required
     */
    onMounted(): void;
    /**
     * Prepare internal services and load configuration
     */
    onBrowserCapabilitiesReady(): void;
    /**
     * Enqueue in buffer the events that were triggered pre SDK initialization
     */
    enqueuePreloadBufferEvents(bufferedEvents: PreloadedEventCall[]): void;
    /**
     * Start the process of consuming the buffered events that were triggered pre SDK initialization
     */
    processDataInPreloadBuffer(): void;
    /**
     * Assign instances for the internal services
     */
    prepareInternalServices(): void;
    /**
     * Load configuration
     */
    loadConfig(): void;
    /**
     * Initialize the storage and event queue
     */
    onPluginsReady(): void;
    /**
     * Load plugins
     */
    onConfigured(): void;
    /**
     * Trigger onLoaded callback if any is provided in config & emit initialised event
     */
    onInitialized(): void;
    /**
     * Emit ready event
     */
    onReady(): void;
    /**
     * Consume preloaded events buffer
     */
    processBufferedEvents(): void;
    /**
     * Load device mode destinations
     */
    loadDestinations(): void;
    /**
     * Invoke the ready callbacks if any exist
     */
    onDestinationsReady(): void;
    /**
     * To register a callback for SDK ready state
     */
    ready(callback: ApiCallback, isBufferedInvocation?: boolean): void;
    /**
     * To record a page view event
     */
    page(pageOptions: PageCallOptions, isBufferedInvocation?: boolean): void;
    /**
     * To record a user track event
     */
    track(trackCallOptions: TrackCallOptions, isBufferedInvocation?: boolean): void;
    /**
     * To record a user identification event
     */
    identify(identifyCallOptions: IdentifyCallOptions, isBufferedInvocation?: boolean): void;
    /**
     * To record a user alias event
     */
    alias(aliasCallOptions: AliasCallOptions, isBufferedInvocation?: boolean): void;
    /**
     * To record a user group event
     */
    group(groupCallOptions: GroupCallOptions, isBufferedInvocation?: boolean): void;
    /**
     * To get anonymousId set in the SDK
     */
    getAnonymousId(options?: AnonymousIdOptions): string | undefined;
    /**
     * To set anonymousId
     */
    setAnonymousId(anonymousId?: string, rudderAmpLinkerParam?: string, isBufferedInvocation?: boolean): void;
    /**
     * Clear user information, optionally anonymousId as well
     */
    reset(resetAnonymousId?: boolean, isBufferedInvocation?: boolean): void;
    /**
     * To get userId set in the SDK
     */
    getUserId(): Nullable<string> | undefined;
    /**
     * To get user traits set in the SDK
     */
    getUserTraits(): Nullable<ApiObject> | undefined;
    /**
     * To get groupId set in the SDK
     */
    getGroupId(): Nullable<string> | undefined;
    /**
     * To get group traits set in the SDK
     */
    getGroupTraits(): Nullable<ApiObject> | undefined;
    /**
     * To manually start user session in the SDK
     */
    startSession(sessionId?: number, isBufferedInvocation?: boolean): void;
    /**
     * To manually end user session in the SDK
     */
    endSession(isBufferedInvocation?: boolean): void;
    /**
     * To fetch the current sessionId
     */
    getSessionId(): Nullable<number>;
    /**
     * To record consent
     * @param options Consent API options
     */
    consent(options?: ConsentOptions, isBufferedInvocation?: boolean): void;
    /**
     * To set auth token
     */
    setAuthToken(token: string): void;
}

declare class RudderAnalytics implements IRudderAnalytics<IAnalytics> {
    static globalSingleton: Nullable<RudderAnalytics>;
    analyticsInstances: Record<string, IAnalytics>;
    defaultAnalyticsKey: string;
    logger: Logger;
    constructor();
    /**
     * Set instance to use if no specific writeKey is provided in methods
     * automatically for the first created instance
     * TODO: to support multiple analytics instances in the near future
     */
    setDefaultInstanceKey(writeKey: string): void;
    /**
     * Retrieve an existing analytics instance
     */
    getAnalyticsInstance(writeKey?: string): IAnalytics | undefined;
    /**
     * Loads the SDK
     * @param writeKey Source write key
     * @param dataPlaneUrl Data plane URL
     * @param loadOptions Additional options for loading the SDK
     * @returns none
     */
    load(writeKey: string, dataPlaneUrl: string, loadOptions?: Partial<LoadOptions>): void;
    /**
     * A function to track page lifecycle events like page loaded and page unloaded
     * @param preloadedEventsArray
     * @param loadOptions
     * @returns
     */
    trackPageLifecycleEvents(preloadedEventsArray: PreloadedEventCall[], loadOptions?: Partial<LoadOptions>): void;
    /**
     * Buffer the page loaded event in the preloaded events array
     * @param events
     * @param options
     * @param preloadedEventsArray
     */
    trackPageLoadedEvent(events: PageLifecycleEvents[], options: ApiOptions, preloadedEventsArray: PreloadedEventCall[]): void;
    /**
     * Setup page unload tracking if enabled
     * @param events
     * @param useBeacon
     * @param options
     */
    setupPageUnloadTracking(events: PageLifecycleEvents[], useBeacon: boolean | undefined, options: ApiOptions): void;
    /**
     * Trigger load event in buffer queue if exists and stores the
     * remaining preloaded events array in global object
     */
    triggerBufferedLoadEvent(): void;
    /**
     * Get ready callback arguments and forward to ready call
     */
    ready(callback: ApiCallback): void;
    /**
     * Process page arguments and forward to page call
     */
    page(category: string, name: string, properties?: Nullable<ApiObject>, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    page(category: string, name: string, properties?: Nullable<ApiObject>, callback?: ApiCallback): void;
    page(category: string, name: string, callback?: ApiCallback): void;
    page(name: string, properties?: Nullable<ApiObject>, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    page(name: string, properties?: Nullable<ApiObject>, callback?: ApiCallback): void;
    page(name: string, callback?: ApiCallback): void;
    page(properties: Nullable<ApiObject>, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    page(properties: Nullable<ApiObject>, callback?: ApiCallback): void;
    page(callback?: ApiCallback): void;
    /**
     * Process track arguments and forward to page call
     */
    track(event: string, properties?: Nullable<ApiObject>, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    track(event: string, properties?: Nullable<ApiObject>, callback?: ApiCallback): void;
    track(event: string, callback?: ApiCallback): void;
    /**
     * Process identify arguments and forward to page call
     */
    identify(userId: string, traits?: Nullable<IdentifyTraits>, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    identify(userId: string, traits?: Nullable<IdentifyTraits>, callback?: ApiCallback): void;
    identify(userId: string, callback?: ApiCallback): void;
    identify(traits: Nullable<IdentifyTraits>, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    identify(traits: Nullable<IdentifyTraits>, callback?: ApiCallback): void;
    /**
     * Process alias arguments and forward to page call
     */
    alias(to: string, from?: string, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    alias(to: string, from?: string, callback?: ApiCallback): void;
    alias(to: string, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    alias(to: string, callback?: ApiCallback): void;
    /**
     * Process group arguments and forward to page call
     */
    group(groupId: string, traits?: Nullable<IdentifyTraits>, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    group(groupId: string, traits?: Nullable<IdentifyTraits>, callback?: ApiCallback): void;
    group(groupId: string, callback?: ApiCallback): void;
    group(traits: Nullable<IdentifyTraits>, options?: Nullable<ApiOptions>, callback?: ApiCallback): void;
    group(traits: Nullable<IdentifyTraits>, callback?: ApiCallback): void;
    reset(resetAnonymousId?: boolean): void;
    getAnonymousId(options?: AnonymousIdOptions): string | undefined;
    setAnonymousId(anonymousId?: string, rudderAmpLinkerParam?: string): void;
    getUserId(): Nullable<string> | undefined;
    getUserTraits(): Nullable<ApiObject> | undefined;
    getGroupId(): Nullable<string> | undefined;
    getGroupTraits(): Nullable<ApiObject> | undefined;
    startSession(sessionId?: number): void;
    endSession(): void;
    getSessionId(): Nullable<number> | undefined;
    setAuthToken(token: string): void;
    consent(options?: ConsentOptions): void;
}
//# sourceMappingURL=RudderAnalytics.d.ts.map

declare global {
    interface Window {
        rudderanalytics: RudderAnalytics | RudderAnalyticsPreloader | undefined;
    }
}
//# sourceMappingURL=index.d.ts.map

export { type AnonymousIdOptions, type ApiCallback, type ApiObject, type ApiOptions, type BeaconQueueOpts, type ConsentOptions, type CookieSameSite, type DestinationsQueueOpts, type IdentifyTraits, type IntegrationOpts, type LoadOptions, type LogLevel, type PluginName, type PreloadedEventCall, type QueueOpts, RudderAnalytics, type RudderAnalyticsPreloader, type SessionOpts, type UaChTrackLevel };
