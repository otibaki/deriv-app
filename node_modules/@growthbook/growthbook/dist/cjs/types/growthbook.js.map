{"version":3,"file":"growthbook.js","names":[],"sources":["../../../src/types/growthbook.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type { GrowthBook, StickyBucketService } from \"..\";\nimport { ConditionInterface, ParentConditionInterface } from \"./mongrule\";\n\ndeclare global {\n  interface Window {\n    _growthbook?: GrowthBook;\n  }\n}\n\nexport type VariationMeta = {\n  passthrough?: boolean;\n  key?: string;\n  name?: string;\n};\n\nexport type FeatureRule<T = any> = {\n  id?: string;\n  condition?: ConditionInterface;\n  parentConditions?: ParentConditionInterface[];\n  force?: T;\n  variations?: T[];\n  weights?: number[];\n  key?: string;\n  hashAttribute?: string;\n  fallbackAttribute?: string;\n  hashVersion?: number;\n  disableStickyBucketing?: boolean;\n  bucketVersion?: number;\n  minBucketVersion?: number;\n  range?: VariationRange;\n  coverage?: number;\n  /** @deprecated */\n  namespace?: [string, number, number];\n  ranges?: VariationRange[];\n  meta?: VariationMeta[];\n  filters?: Filter[];\n  seed?: string;\n  name?: string;\n  phase?: string;\n  tracks?: Array<{\n    experiment: Experiment<T>;\n    result: Result<T>;\n  }>;\n};\n\nexport interface FeatureDefinition<T = any> {\n  defaultValue?: T;\n  rules?: FeatureRule<T>[];\n}\n\nexport type FeatureResultSource =\n  | \"unknownFeature\"\n  | \"defaultValue\"\n  | \"force\"\n  | \"override\"\n  | \"experiment\"\n  | \"prerequisite\"\n  | \"cyclicPrerequisite\";\n\nexport interface FeatureResult<T = any> {\n  value: T | null;\n  source: FeatureResultSource;\n  on: boolean;\n  off: boolean;\n  ruleId: string;\n  experiment?: Experiment<T>;\n  experimentResult?: Result<T>;\n}\n\n/** @deprecated */\nexport type ExperimentStatus = \"draft\" | \"running\" | \"stopped\";\n\nexport type UrlTargetType = \"regex\" | \"simple\";\n\nexport type UrlTarget = {\n  include: boolean;\n  type: UrlTargetType;\n  pattern: string;\n};\n\nexport type Experiment<T> = {\n  key: string;\n  variations: [T, T, ...T[]];\n  ranges?: VariationRange[];\n  meta?: VariationMeta[];\n  filters?: Filter[];\n  seed?: string;\n  name?: string;\n  phase?: string;\n  urlPatterns?: UrlTarget[];\n  weights?: number[];\n  condition?: ConditionInterface;\n  parentConditions?: ParentConditionInterface[];\n  coverage?: number;\n  include?: () => boolean;\n  /** @deprecated */\n  namespace?: [string, number, number];\n  force?: number;\n  hashAttribute?: string;\n  fallbackAttribute?: string;\n  hashVersion?: number;\n  disableStickyBucketing?: boolean;\n  bucketVersion?: number;\n  minBucketVersion?: number;\n  active?: boolean;\n  persistQueryString?: boolean;\n  /** @deprecated */\n  status?: ExperimentStatus;\n  /** @deprecated */\n  url?: RegExp;\n  /** @deprecated */\n  groups?: string[];\n};\n\nexport type AutoExperimentChangeType = \"redirect\" | \"visual\" | \"unknown\";\n\nexport type AutoExperiment<T = AutoExperimentVariation> = Experiment<T> & {\n  changeId?: string;\n  // If true, require the experiment to be manually triggered\n  manual?: boolean;\n};\n\nexport type ExperimentOverride = {\n  condition?: ConditionInterface;\n  weights?: number[];\n  active?: boolean;\n  status?: ExperimentStatus;\n  force?: number;\n  coverage?: number;\n  groups?: string[];\n  namespace?: [string, number, number];\n  url?: RegExp | string;\n};\n\nexport interface Result<T> {\n  value: T;\n  variationId: number;\n  key: string;\n  name?: string;\n  bucket?: number;\n  passthrough?: boolean;\n  inExperiment: boolean;\n  hashUsed?: boolean;\n  hashAttribute: string;\n  hashValue: string;\n  featureId: string | null;\n  stickyBucketUsed?: boolean;\n}\n\nexport type Attributes = Record<string, any>;\n\nexport interface TrackingData {\n  experiment: Experiment<any>;\n  result: Result<any>;\n}\n\nexport interface TrackingDataWithUser {\n  experiment: Experiment<any>;\n  result: Result<any>;\n  user: UserContext;\n}\n\nexport type TrackingCallback = (\n  experiment: Experiment<any>,\n  result: Result<any>\n) => Promise<void> | void;\n\nexport type TrackingCallbackWithUser = (\n  experiment: Experiment<any>,\n  result: Result<any>,\n  user: UserContext\n) => Promise<void> | void;\n\nexport type FeatureUsageCallback = (\n  key: string,\n  result: FeatureResult<any>\n) => void;\n\nexport type FeatureUsageCallbackWithUser = (\n  key: string,\n  result: FeatureResult<any>,\n  user: UserContext\n) => void;\n\nexport type NavigateCallback = (url: string) => void | Promise<void>;\n\nexport type ApplyDomChangesCallback = (\n  changes: AutoExperimentVariation\n) => () => void;\n\nexport type RenderFunction = () => void;\n\n// Constructor Options\nexport type Options = {\n  enabled?: boolean;\n  attributes?: Attributes;\n  url?: string;\n  features?: Record<string, FeatureDefinition>;\n  experiments?: AutoExperiment[];\n  forcedVariations?: Record<string, number>;\n  blockedChangeIds?: string[];\n  disableVisualExperiments?: boolean;\n  disableJsInjection?: boolean;\n  jsInjectionNonce?: string;\n  disableUrlRedirectExperiments?: boolean;\n  disableCrossOriginUrlRedirectExperiments?: boolean;\n  disableExperimentsOnLoad?: boolean;\n  stickyBucketAssignmentDocs?: Record<\n    StickyAttributeKey,\n    StickyAssignmentsDocument\n  >;\n  stickyBucketService?: StickyBucketService;\n  debug?: boolean;\n  log?: (msg: string, ctx: any) => void;\n  qaMode?: boolean;\n  /** @deprecated */\n  backgroundSync?: boolean;\n  /** @deprecated */\n  subscribeToChanges?: boolean;\n  enableDevMode?: boolean;\n  disableCache?: boolean;\n  /** @deprecated */\n  disableDevTools?: boolean;\n  trackingCallback?: TrackingCallback;\n  onFeatureUsage?: (key: string, result: FeatureResult<any>) => void;\n  cacheKeyAttributes?: (keyof Attributes)[];\n  /** @deprecated */\n  user?: {\n    id?: string;\n    anonId?: string;\n    [key: string]: string | undefined;\n  };\n  /** @deprecated */\n  overrides?: Record<string, ExperimentOverride>;\n  /** @deprecated */\n  groups?: Record<string, boolean>;\n  apiHost?: string;\n  streamingHost?: string;\n  apiHostRequestHeaders?: Record<string, string>;\n  streamingHostRequestHeaders?: Record<string, string>;\n  clientKey?: string;\n  renderer?: null | RenderFunction;\n  decryptionKey?: string;\n  remoteEval?: boolean;\n  navigate?: NavigateCallback;\n  navigateDelay?: number;\n  maxNavigateDelay?: number;\n  /** @deprecated */\n  antiFlicker?: boolean;\n  /** @deprecated */\n  antiFlickerTimeout?: number;\n  applyDomChangesCallback?: ApplyDomChangesCallback;\n  savedGroups?: SavedGroupsValues;\n};\n\nexport type ClientOptions = {\n  enabled?: boolean;\n  debug?: boolean;\n  globalAttributes?: Attributes;\n  forcedVariations?: Record<string, number>;\n  forcedFeatureValues?: Map<string, any>;\n  log?: (msg: string, ctx: any) => void;\n  qaMode?: boolean;\n  disableCache?: boolean;\n  trackingCallback?: TrackingCallbackWithUser;\n  onFeatureUsage?: (\n    key: string,\n    result: FeatureResult<any>,\n    user: UserContext\n  ) => void;\n  apiHost?: string;\n  streamingHost?: string;\n  apiHostRequestHeaders?: Record<string, string>;\n  streamingHostRequestHeaders?: Record<string, string>;\n  clientKey?: string;\n  decryptionKey?: string;\n  savedGroups?: SavedGroupsValues;\n};\n\n// Contexts\nexport type GlobalContext = {\n  log: (msg: string, ctx: any) => void;\n  features?: FeatureDefinitions;\n  experiments?: AutoExperiment[];\n  enabled?: boolean;\n  qaMode?: boolean;\n  savedGroups?: SavedGroupsValues;\n  forcedVariations?: Record<string, number>;\n  forcedFeatureValues?: Map<string, any>;\n  trackingCallback?: TrackingCallbackWithUser;\n  onFeatureUsage?: FeatureUsageCallbackWithUser;\n  onExperimentEval?: (experiment: Experiment<any>, result: Result<any>) => void;\n  saveDeferredTrack?: (data: TrackingData) => void;\n  recordChangeId?: (changeId: string) => void;\n\n  /** @deprecated */\n  overrides?: Record<string, ExperimentOverride>;\n  /** @deprecated */\n  groups?: Record<string, boolean>;\n  /** @deprecated */\n  user?: {\n    id?: string;\n    anonId?: string;\n    [key: string]: string | undefined;\n  };\n};\n\n// Some global fields can be overridden by the user, others are always user-level\nexport type UserContext = {\n  enabled?: boolean;\n  qaMode?: boolean;\n  attributes?: Attributes;\n  url?: string;\n  blockedChangeIds?: string[];\n  stickyBucketAssignmentDocs?: Record<\n    StickyAttributeKey,\n    StickyAssignmentsDocument\n  >;\n  saveStickyBucketAssignmentDoc?: (\n    doc: StickyAssignmentsDocument\n  ) => Promise<unknown>;\n  forcedVariations?: Record<string, number>;\n  forcedFeatureValues?: Map<string, any>;\n  trackingCallback?: TrackingCallback;\n  onFeatureUsage?: FeatureUsageCallback;\n};\n\nexport type StackContext = {\n  id?: string;\n  evaluatedFeatures: Set<string>;\n};\n\nexport type EvalContext = {\n  global: GlobalContext;\n  user: UserContext;\n  stack: StackContext;\n};\n\nexport type PrefetchOptions = Pick<\n  Options,\n  | \"decryptionKey\"\n  | \"apiHost\"\n  | \"apiHostRequestHeaders\"\n  | \"streamingHost\"\n  | \"streamingHostRequestHeaders\"\n> & {\n  clientKey: string;\n  streaming?: boolean;\n  skipCache?: boolean;\n};\n\nexport type SubscriptionFunction = (\n  experiment: Experiment<any>,\n  result: Result<any>\n) => void;\n\nexport type VariationRange = [number, number];\n\nexport interface InitResponse {\n  // If a payload was set\n  success: boolean;\n  // Where the payload came from, if set\n  source: \"init\" | \"cache\" | \"network\" | \"error\" | \"timeout\";\n  // If the payload could not be set (success = false), this will hold the fetch error\n  error?: Error;\n}\n\nexport interface FetchResponse {\n  data: FeatureApiResponse | null;\n  success: boolean;\n  source: \"cache\" | \"network\" | \"error\" | \"timeout\";\n  error?: Error;\n}\n\nexport type JSONValue =\n  | null\n  | number\n  | string\n  | boolean\n  | Array<JSONValue>\n  | Record<string, unknown>\n  | { [key: string]: JSONValue };\n\nexport type WidenPrimitives<T> = T extends string\n  ? string\n  : T extends number\n  ? number\n  : T extends boolean\n  ? boolean\n  : T;\n\nexport type DOMMutation = {\n  selector: string;\n  action: string;\n  attribute: string;\n  value?: string;\n  parentSelector?: string;\n  insertBeforeSelector?: string;\n};\n\nexport type AutoExperimentVariation = {\n  domMutations?: DOMMutation[];\n  css?: string;\n  js?: string;\n  urlRedirect?: string;\n};\n\nexport type FeatureDefinitions = Record<string, FeatureDefinition>;\n\nexport type FeatureApiResponse = {\n  features?: FeatureDefinitions;\n  dateUpdated?: string;\n  encryptedFeatures?: string;\n  experiments?: AutoExperiment[];\n  encryptedExperiments?: string;\n  savedGroups?: SavedGroupsValues;\n  encryptedSavedGroups?: string;\n};\n\n// Alias\nexport type GrowthBookPayload = FeatureApiResponse;\n\n// Polyfills required for non-standard browser environments (ReactNative, Node, etc.)\n// These are typed as `any` since polyfills like `node-fetch` are not 100% compatible with native types\nexport type Polyfills = {\n  // eslint-disable-next-line\n  fetch: any;\n  // eslint-disable-next-line\n  SubtleCrypto: any;\n  // eslint-disable-next-line\n  EventSource: any;\n  localStorage?: LocalStorageCompat;\n};\n\nexport type Helpers = {\n  fetchFeaturesCall: ({\n    host,\n    clientKey,\n    headers,\n  }: {\n    host: string;\n    clientKey: string;\n    headers?: Record<string, string>;\n  }) => Promise<Response>;\n  fetchRemoteEvalCall: ({\n    host,\n    clientKey,\n    payload,\n    headers,\n  }: {\n    host: string;\n    clientKey: string;\n    // eslint-disable-next-line\n    payload: any;\n    headers?: Record<string, string>;\n  }) => Promise<Response>;\n  eventSourceCall: ({\n    host,\n    clientKey,\n    headers,\n  }: {\n    host: string;\n    clientKey: string;\n    headers?: Record<string, string>;\n  }) => EventSource;\n  startIdleListener: () => (() => void) | void;\n  stopIdleListener: () => void;\n};\n\nexport interface LocalStorageCompat {\n  getItem(key: string): string | null | Promise<string | null>;\n  setItem(key: string, value: string): void | Promise<void>;\n}\n\nexport type CacheSettings = {\n  backgroundSync: boolean;\n  cacheKey: string;\n  staleTTL: number;\n  maxAge: number;\n  maxEntries: number;\n  disableIdleStreams: boolean;\n  idleStreamInterval: number;\n  disableCache: boolean;\n};\n\nexport type ApiHost = string;\nexport type ClientKey = string;\n\nexport type InitOptions = {\n  timeout?: number;\n  skipCache?: boolean;\n  payload?: FeatureApiResponse;\n  streaming?: boolean;\n  cacheSettings?: CacheSettings;\n};\n\nexport type InitSyncOptions = {\n  payload: FeatureApiResponse;\n  streaming?: boolean;\n};\n\nexport type LoadFeaturesOptions = {\n  /** @deprecated */\n  autoRefresh?: boolean;\n  timeout?: number;\n  skipCache?: boolean;\n};\n\nexport type RefreshFeaturesOptions = {\n  timeout?: number;\n  skipCache?: boolean;\n};\n\nexport interface Filter {\n  // Override the hashAttribute used for this filter\n  attribute?: string;\n  // The hash seed\n  seed: string;\n  // The hashing version to use\n  hashVersion: number;\n  // Only include these resulting ranges\n  ranges: VariationRange[];\n}\n\nexport type StickyAttributeKey = string; // `${attributeName}||${attributeValue}`\nexport type StickyExperimentKey = string; // `${experimentId}__{version}`\nexport type StickyAssignments = Record<StickyExperimentKey, string>;\nexport interface StickyAssignmentsDocument {\n  attributeName: string;\n  attributeValue: string;\n  assignments: StickyAssignments;\n}\n\nexport type SavedGroupsValues = Record<string, (string | number)[]>;\n"],"mappings":""}