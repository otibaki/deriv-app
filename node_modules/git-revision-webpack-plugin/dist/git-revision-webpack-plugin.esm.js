import { exec, execSync } from 'child_process';
import path from 'path';

function removeEmptyLines(string) {
  return string.replace(/[\s\r\n]+$/, '');
}

function runGitCommand (gitWorkTree, command, callback) {
  var gitCommand = gitWorkTree ? ['git', '--git-dir=' + path.join(gitWorkTree, '.git'), '--work-tree=' + gitWorkTree, command].join(' ') : ['git', command].join(' ');

  if (callback) {
    exec(gitCommand, function (err, stdout) {
      if (err) {
        return callback(err, '');
      }

      callback(null, removeEmptyLines(stdout));
    });
    return null;
  } else {
    return removeEmptyLines("" + execSync(gitCommand));
  }
}

function buildFile(_ref) {
  var compiler = _ref.compiler,
      gitWorkTree = _ref.gitWorkTree,
      command = _ref.command,
      replacePattern = _ref.replacePattern,
      asset = _ref.asset;
  var data = '';
  compiler.hooks.compilation.tap('GitRevisionWebpackPlugin', function (compilation) {
    compilation.hooks.optimizeTree.tapAsync('optimize-tree', function (_, __, callback) {
      runGitCommand(gitWorkTree, command, function (err, res) {
        if (err) {
          return callback(err);
        }

        data = res;
        callback();
      });
    });
    compilation.hooks.assetPath.tap('GitRevisionWebpackPlugin', function (assetPath, chunkData) {
      var path = typeof assetPath === 'function' ? assetPath(chunkData) : assetPath;
      if (!data) return path;
      return path.replace(replacePattern, data);
    });
    compilation.hooks.processAssets.tap('GitRevisionWebpackPlugin', function (assets) {
      assets[asset] = {
        source: function source() {
          return data;
        },
        size: function size() {
          return data ? data.length : 0;
        },
        buffer: function buffer() {
          return Buffer.from(data);
        },
        map: function map() {
          return {};
        },
        sourceAndMap: function sourceAndMap() {
          return {
            source: data,
            map: {}
          };
        },
        updateHash: function updateHash() {}
      };
    });
  });
}

var COMMITHASH_COMMAND = 'rev-parse HEAD';
var VERSION_COMMAND = 'describe --always';
var BRANCH_COMMAND = 'rev-parse --abbrev-ref HEAD';
var LASTCOMMITDATETIME_COMMAND = 'log -1 --format=%cI';
var GitRevisionPlugin = /*#__PURE__*/function () {
  function GitRevisionPlugin(options) {
    if (options === void 0) {
      options = {};
    }

    this.gitWorkTree = options.gitWorkTree;
    this.commithashCommand = options.commithashCommand || COMMITHASH_COMMAND;
    this.versionCommand = options.versionCommand || VERSION_COMMAND + (options.lightweightTags ? ' --tags' : '');
    this.createBranchFile = options.branch || false;
    this.branchCommand = options.branchCommand || BRANCH_COMMAND;
    this.lastCommitDateTimeCommand = options.lastCommitDateTimeCommand || LASTCOMMITDATETIME_COMMAND;

    if (options.versionCommand && options.lightweightTags) {
      throw new Error("lightweightTags can't be used together versionCommand");
    }
  }

  var _proto = GitRevisionPlugin.prototype;

  _proto.commithash = function commithash() {
    return runGitCommand(this.gitWorkTree, this.commithashCommand);
  };

  _proto.version = function version() {
    return runGitCommand(this.gitWorkTree, this.versionCommand);
  };

  _proto.branch = function branch() {
    return runGitCommand(this.gitWorkTree, this.branchCommand);
  };

  _proto.lastcommitdatetime = function lastcommitdatetime() {
    return runGitCommand(this.gitWorkTree, this.lastCommitDateTimeCommand);
  };

  _proto.apply = function apply(compiler) {
    buildFile({
      compiler: compiler,
      gitWorkTree: this.gitWorkTree,
      command: this.commithashCommand,
      replacePattern: /\[git-revision-hash\]/gi,
      asset: 'COMMITHASH'
    });
    buildFile({
      compiler: compiler,
      gitWorkTree: this.gitWorkTree,
      command: this.versionCommand,
      replacePattern: /\[git-revision-version\]/gi,
      asset: 'VERSION'
    });
    buildFile({
      compiler: compiler,
      gitWorkTree: this.gitWorkTree,
      command: this.lastCommitDateTimeCommand,
      replacePattern: /\[git-revision-last-commit-datetime\]/gi,
      asset: 'LASTCOMMITDATETIME'
    });

    if (this.createBranchFile) {
      buildFile({
        compiler: compiler,
        gitWorkTree: this.gitWorkTree,
        command: this.branchCommand,
        replacePattern: /\[git-revision-branch\]/gi,
        asset: 'BRANCH'
      });
    }
  };

  return GitRevisionPlugin;
}();

export { GitRevisionPlugin };
//# sourceMappingURL=git-revision-webpack-plugin.esm.js.map
